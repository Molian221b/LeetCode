# 我的超时写法 -_-
# class Solution:
#     def maxProfit(self, prices):
#         prices.append(0)
#         buy = 0
#         buy_list = []
#         sell_list = []

#         for i in range(1,len(prices)):
#             if prices[i] > prices[buy] and prices[i] > prices[i+1]:
#                 buy_list.append(prices[buy])
#                 sell_list.append(prices[i])
#                 buy = i+1
#             elif prices[i] < prices[buy]:
#                 buy = i

#         if len(sell_list) == 0:   #防止[5,4,3,2,1]
#             return 0
#         elif len(sell_list) == 1: #防止[1,2,3,4,5]
#             return sell_list[0] - buy_list[0]

#         prices.pop()
#         profit = []
#         for i in range(len(buy_list)):
#             for j in range(i,len(sell_list)): #实际上buy_list == sell_list
#                 profit.append([sell_list[j] - buy_list[i], i, j])
#                 #这时profit变成了二维列表，目的是为了检测后面
#                 #sell_list[j] - buy_list[i]是否用了同一个sell_list[i]

#         profit.sort(reverse = True)
#         profit_max = profit[0][0]

#         for i in range(len(profit)-1):
#             for j in range(i+1, len(profit)):
#                 #这个if是为了保证买一次卖一次而不是买几次再卖几次
#                 if profit[i][1] > profit[j][2] or profit[i][2] < profit[j][1]:
#                     profit_max = max(profit_max, profit[i][0] + profit[j][0])

#         return profit_max
